// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v5.29.3
// source: isms/v1/software.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationSoftwareCreateSoftware = "/isms.v1.Software/CreateSoftware"
const OperationSoftwareGetSoftwareById = "/isms.v1.Software/GetSoftwareById"
const OperationSoftwareListSoftware = "/isms.v1.Software/ListSoftware"
const OperationSoftwareUpdateSoftware = "/isms.v1.Software/UpdateSoftware"

type SoftwareHTTPServer interface {
	// CreateSoftware 创建工业软件记录
	CreateSoftware(context.Context, *CreateSoftwareReq) (*CreateSoftwareResp, error)
	// GetSoftwareById 根据ID查询单个软件（修正：参数传递方式）
	GetSoftwareById(context.Context, *GetSoftwareByIdReq) (*IsmsSoftware, error)
	// ListSoftware 分页查询工业软件记录
	ListSoftware(context.Context, *ListSoftwareReq) (*ListSoftwareResp, error)
	// UpdateSoftware 更新工业软件记录
	UpdateSoftware(context.Context, *UpdateSoftwareReq) (*UpdateSoftwareResp, error)
}

func RegisterSoftwareHTTPServer(s *http.Server, srv SoftwareHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/software", _Software_CreateSoftware0_HTTP_Handler(srv))
	r.PUT("/v1/software/{id}", _Software_UpdateSoftware0_HTTP_Handler(srv))
	r.GET("/v1/software", _Software_ListSoftware0_HTTP_Handler(srv))
	r.GET("/v1/software/{id}", _Software_GetSoftwareById0_HTTP_Handler(srv))
}

func _Software_CreateSoftware0_HTTP_Handler(srv SoftwareHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateSoftwareReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSoftwareCreateSoftware)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateSoftware(ctx, req.(*CreateSoftwareReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*CreateSoftwareResp)
		return ctx.Result(200, reply)
	}
}

func _Software_UpdateSoftware0_HTTP_Handler(srv SoftwareHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateSoftwareReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSoftwareUpdateSoftware)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateSoftware(ctx, req.(*UpdateSoftwareReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*UpdateSoftwareResp)
		return ctx.Result(200, reply)
	}
}

func _Software_ListSoftware0_HTTP_Handler(srv SoftwareHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListSoftwareReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSoftwareListSoftware)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListSoftware(ctx, req.(*ListSoftwareReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListSoftwareResp)
		return ctx.Result(200, reply)
	}
}

func _Software_GetSoftwareById0_HTTP_Handler(srv SoftwareHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetSoftwareByIdReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationSoftwareGetSoftwareById)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetSoftwareById(ctx, req.(*GetSoftwareByIdReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*IsmsSoftware)
		return ctx.Result(200, reply)
	}
}

type SoftwareHTTPClient interface {
	CreateSoftware(ctx context.Context, req *CreateSoftwareReq, opts ...http.CallOption) (rsp *CreateSoftwareResp, err error)
	GetSoftwareById(ctx context.Context, req *GetSoftwareByIdReq, opts ...http.CallOption) (rsp *IsmsSoftware, err error)
	ListSoftware(ctx context.Context, req *ListSoftwareReq, opts ...http.CallOption) (rsp *ListSoftwareResp, err error)
	UpdateSoftware(ctx context.Context, req *UpdateSoftwareReq, opts ...http.CallOption) (rsp *UpdateSoftwareResp, err error)
}

type SoftwareHTTPClientImpl struct {
	cc *http.Client
}

func NewSoftwareHTTPClient(client *http.Client) SoftwareHTTPClient {
	return &SoftwareHTTPClientImpl{client}
}

func (c *SoftwareHTTPClientImpl) CreateSoftware(ctx context.Context, in *CreateSoftwareReq, opts ...http.CallOption) (*CreateSoftwareResp, error) {
	var out CreateSoftwareResp
	pattern := "/v1/software"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationSoftwareCreateSoftware))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SoftwareHTTPClientImpl) GetSoftwareById(ctx context.Context, in *GetSoftwareByIdReq, opts ...http.CallOption) (*IsmsSoftware, error) {
	var out IsmsSoftware
	pattern := "/v1/software/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationSoftwareGetSoftwareById))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SoftwareHTTPClientImpl) ListSoftware(ctx context.Context, in *ListSoftwareReq, opts ...http.CallOption) (*ListSoftwareResp, error) {
	var out ListSoftwareResp
	pattern := "/v1/software"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationSoftwareListSoftware))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *SoftwareHTTPClientImpl) UpdateSoftware(ctx context.Context, in *UpdateSoftwareReq, opts ...http.CallOption) (*UpdateSoftwareResp, error) {
	var out UpdateSoftwareResp
	pattern := "/v1/software/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationSoftwareUpdateSoftware))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
