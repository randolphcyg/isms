// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.8.4
// - protoc             v5.29.3
// source: isms/v1/os.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationOSCreateOS = "/isms.v1.OS/CreateOS"
const OperationOSDeleteOS = "/isms.v1.OS/DeleteOS"
const OperationOSGetOS = "/isms.v1.OS/GetOS"
const OperationOSListOS = "/isms.v1.OS/ListOS"
const OperationOSUpdateOS = "/isms.v1.OS/UpdateOS"

type OSHTTPServer interface {
	// CreateOS 创建操作系统
	CreateOS(context.Context, *CreateOSReq) (*OSResp, error)
	// DeleteOS 删除操作系统
	DeleteOS(context.Context, *DeleteOSReq) (*DeleteOSResp, error)
	// GetOS 查询单个操作系统
	GetOS(context.Context, *GetOSReq) (*OSResp, error)
	// ListOS 分页查询操作系统列表
	ListOS(context.Context, *ListOSReq) (*ListOSResp, error)
	// UpdateOS 更新操作系统
	UpdateOS(context.Context, *UpdateOSReq) (*OSResp, error)
}

func RegisterOSHTTPServer(s *http.Server, srv OSHTTPServer) {
	r := s.Route("/")
	r.POST("/v1/os", _OS_CreateOS0_HTTP_Handler(srv))
	r.PUT("/v1/os/{id}", _OS_UpdateOS0_HTTP_Handler(srv))
	r.DELETE("/v1/os/{id}", _OS_DeleteOS0_HTTP_Handler(srv))
	r.GET("/v1/os/{id}", _OS_GetOS0_HTTP_Handler(srv))
	r.GET("/v1/os", _OS_ListOS0_HTTP_Handler(srv))
}

func _OS_CreateOS0_HTTP_Handler(srv OSHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in CreateOSReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationOSCreateOS)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.CreateOS(ctx, req.(*CreateOSReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*OSResp)
		return ctx.Result(200, reply)
	}
}

func _OS_UpdateOS0_HTTP_Handler(srv OSHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in UpdateOSReq
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationOSUpdateOS)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.UpdateOS(ctx, req.(*UpdateOSReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*OSResp)
		return ctx.Result(200, reply)
	}
}

func _OS_DeleteOS0_HTTP_Handler(srv OSHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in DeleteOSReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationOSDeleteOS)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.DeleteOS(ctx, req.(*DeleteOSReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*DeleteOSResp)
		return ctx.Result(200, reply)
	}
}

func _OS_GetOS0_HTTP_Handler(srv OSHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in GetOSReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationOSGetOS)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.GetOS(ctx, req.(*GetOSReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*OSResp)
		return ctx.Result(200, reply)
	}
}

func _OS_ListOS0_HTTP_Handler(srv OSHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ListOSReq
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationOSListOS)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ListOS(ctx, req.(*ListOSReq))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ListOSResp)
		return ctx.Result(200, reply)
	}
}

type OSHTTPClient interface {
	CreateOS(ctx context.Context, req *CreateOSReq, opts ...http.CallOption) (rsp *OSResp, err error)
	DeleteOS(ctx context.Context, req *DeleteOSReq, opts ...http.CallOption) (rsp *DeleteOSResp, err error)
	GetOS(ctx context.Context, req *GetOSReq, opts ...http.CallOption) (rsp *OSResp, err error)
	ListOS(ctx context.Context, req *ListOSReq, opts ...http.CallOption) (rsp *ListOSResp, err error)
	UpdateOS(ctx context.Context, req *UpdateOSReq, opts ...http.CallOption) (rsp *OSResp, err error)
}

type OSHTTPClientImpl struct {
	cc *http.Client
}

func NewOSHTTPClient(client *http.Client) OSHTTPClient {
	return &OSHTTPClientImpl{client}
}

func (c *OSHTTPClientImpl) CreateOS(ctx context.Context, in *CreateOSReq, opts ...http.CallOption) (*OSResp, error) {
	var out OSResp
	pattern := "/v1/os"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationOSCreateOS))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *OSHTTPClientImpl) DeleteOS(ctx context.Context, in *DeleteOSReq, opts ...http.CallOption) (*DeleteOSResp, error) {
	var out DeleteOSResp
	pattern := "/v1/os/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationOSDeleteOS))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *OSHTTPClientImpl) GetOS(ctx context.Context, in *GetOSReq, opts ...http.CallOption) (*OSResp, error) {
	var out OSResp
	pattern := "/v1/os/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationOSGetOS))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *OSHTTPClientImpl) ListOS(ctx context.Context, in *ListOSReq, opts ...http.CallOption) (*ListOSResp, error) {
	var out ListOSResp
	pattern := "/v1/os"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationOSListOS))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *OSHTTPClientImpl) UpdateOS(ctx context.Context, in *UpdateOSReq, opts ...http.CallOption) (*OSResp, error) {
	var out OSResp
	pattern := "/v1/os/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationOSUpdateOS))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, nil
}
